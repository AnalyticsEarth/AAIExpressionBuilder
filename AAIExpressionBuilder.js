define( [ "qlik",
'text!./template.ng.html',
'./definition',
'text!./dialog-template.ng.html',
'css!./AAIExpressionBuilderStyle.css',
'./wizardList',
'util',
'enigma',
'autogenerated/qix/engine-api'
],
function ( qlik, template, definition, dialogTemplate, cssStyle, wizardList, Util, enigma, schema) {
	'use strict';
	return {
		support : {
			snapshot: false,
			export: false,
			exportData : false
		},
		template: template,
		definition: definition,
		controller: ['$scope','luiDialog', function ( $scope, luiDialog) {
			$scope.wizardList = wizardList;

			/* This function opens the dialog window when the openWizard() function
			is called */
			$scope.openWizard = function(){
				luiDialog.show({
					template: dialogTemplate,
					input: {
						selectedKey: '',
						wizardName: '',
						wizardList: $scope.wizardList,
						appModel: $scope.component.model.app
					},
					controller: ['$scope', function( $scope ) {

						/* Get current Qlik App and field list */
						var app = qlik.currApp(this);
						app.getList("FieldList", function(reply){
							$scope.input.fieldList = reply;
						});

						/* This utility function is called when conversion a written JSON
						path from a config template and returnin the required object
						in the template */
						$scope.objectByString = function(o, s) {
							s = s.replace(/\[(\w+)\]/g, '.$1');
							s = s.replace(/^\./, '');
							var a = s.split('.');
							for (var i = 0, n = a.length; i < n; ++i) {
								var k = a[i];
								if (k in o) {
									o = o[k];
								} else {
									return;
								}
							}
							return o;
						};

						/* Set the default tab and create the function which will allow for
						the tab to be changed in code */
						$scope.tabs = 'tab1';
						$scope.make_tab_active = function(tabid) {
							$scope.tabs = 'tab'+tabid;
							console.log($scope.tabs);
						}

						$scope.make_tab_active(1);


						/* Prep the input list boxes that are used for parameter capture
						on the input form */
						$scope.input.idList = [];
						$scope.input.aggList = ['Count','Sum','Min','Max','Avg'];
						$scope.input.dateAggList = [
							{level:'Week', frequency:52, function:'weekno(##DATE##)'},
							{level:'Month', frequency:12, function:'month(##DATE##)'}
						];

						/* Function called when the selected wizard is changed using the
						onscreen drop down */
						$scope.changeWizard = function(wizKey){
							$scope.input.selectedKey = wizKey;
							$scope.input.wizardName = $scope.input.wizardList[wizKey].name;
							$scope.loadUI(wizKey);
						};

						/* Loads the UI when a change to the wizard is made */
						$scope.loadUI = function(wizKey){
							$scope.input.uiarray = null;
							$scope.input.codeTemplates = null;

							/* Parameters List */
							$scope.input.uiarray = $scope.input.wizardList[wizKey].parameters;
							$scope.input.uiarray.forEach(function(entry){
								entry.inputvalue = '';
							});

							/* Master Items to be created list */
							$scope.input.codeTemplates = $scope.input.wizardList[wizKey].templates;
							$scope.input.codeTemplates.forEach(function(entry){
								entry.enabled = true;
							});

							/* Visualizations to be created list */
							$scope.input.vizTemplates = $scope.input.wizardList[wizKey].viz;
							$scope.input.vizTemplates.forEach(function(entry){
								entry.enabled = true;
							});
						};

						/* Called when the template parameters need to be turned into the
						Qlik expression that is required for the master item */
						$scope.completeTemplates = function(){
							$scope.input.codeTemplates.forEach(function(t){

								/* Process R scripts */
								if(t.scriptType == 'r'){
									$scope.rScriptTemplate(t);
								}

								/* Process fields generated from Qlik native date fields */
								if(t.scriptType == 'nativedate'){
									$scope.nativeDateTemplate(t);
								}

								/* Process a native Qlik field */
								if(t.scriptType == 'nativefield'){
									$scope.nativeFieldTemplate(t);
								}

								/* Process a native Qlik aggregation field */
								if(t.scriptType == 'nativeagg'){
									$scope.nativeFieldAggTemplate(t);
								}

							});
						};

						/* R script template processing */
						$scope.rScriptTemplate = function(t){
							t.outCode = null;

							if(t.enabled){
								//Process Template
								var rScript = t.rscript;
								var qParams = '';
								$scope.input.uiarray.forEach(function(p){
									var regExp = new RegExp('##<'+p.scriptid+'>##','g');
									rScript = rScript.replace(regExp,p.scriptid);

									if(p.includeinfunction){
										if(qParams != ''){
											qParams = qParams + ', ';
										}
										var expressionvalue = '';
										if(p.includeagg){
											expressionvalue = p.aggvalue + '([' + p.inputvalue + '])';
										}else{
											expressionvalue = '[' + p.inputvalue + ']';
										}
										qParams = qParams + expressionvalue + ' as ' + p.scriptid;
									}

								});

								var output = t.qlikfunction + '(\'' + rScript + '\',' + qParams + ')';

								t.outCode = output;
							}
						};

						/* Native date functions */
						$scope.nativeDateTemplate = function(t){
							t.outCode = null;

							if(t.enabled){
								var output = '';
								//Would be better with a match, but looping for the moment!
								$scope.input.uiarray.forEach(function(p){
									if(p.scriptid == t.idForDate){
										output = p.dateaggvalue + '([' + p.inputvalue + '])';
									}
								});
								t.outCode = output;
							}

						};

						/* Native field functions */
						$scope.nativeFieldTemplate = function(t){
							t.outCode = null;

							if(t.enabled){
								var output = '';
								//Would be better with a match, but looping for the moment!
								$scope.input.uiarray.forEach(function(p){
									if(p.scriptid == t.idForField){
										output = '[' + p.inputvalue + ']';
									}
								});
								t.outCode = output;
							}
						};

						/* Native Aggregation functions */
						$scope.nativeFieldAggTemplate = function(t){
							t.outCode = null;

							if(t.enabled){
								var output = '';
								//Would be better with a match, but looping for the moment!
								$scope.input.uiarray.forEach(function(p){
									if(p.scriptid == t.idForField){
										output = p.aggvalue + '([' + p.inputvalue + '])';
									}
								});
								t.outCode = output;
							}
						};

						/* Preview Master Items function, will complete each template so has to
						be called even if preview on screen is not required */
						$scope.previewMasterItems = function(){
							$scope.completeTemplates();
							$scope.make_tab_active(2);
						};

						/* Create Master Items */
						$scope.createMasterItems = function(){
							$scope.previewMasterItems();

							var p = [];
							$scope.input.codeTemplates.forEach(function(t){
								console.log(t.outCode);

								if(t.type.toUpperCase() == 'DIMENSION'){
									var a = $scope.createDimension(t.outCode, t.name, t.description, [], t.id);
									p.push(a);
								}
								if(t.type.toUpperCase() == 'MEASURE'){
									var a = $scope.createMeasure(t.outCode, t.name, t.description, [], t.id);
									p.push(a);
								}

							});

							/* Only process after all promises have competed */
							Promise.all(p).then(values => {
								console.log($scope.input.dimList);
								console.log($scope.input.measureList);
								$scope.input.vizTemplates.forEach(function(v){
									$scope.createMasterViz(v);
								});

							});

						};

						/* Create Dimension */
						$scope.createDimension = function(aeExpression, aeTitle, aeDescription, aeTags, aeTemplateId){
							var dimJSON =
							{
								qInfo: {
									qType: "dimension"
								},
								qDim: {
									qGrouping: "N",
									qFieldDefs: [
										aeExpression
									],
									qFieldLabels: [
										aeTitle
									],
									title:aeTitle
								},
								qMetaDef: {
									title:aeTitle,
									description:aeDescription,
									tags:aeTags
								}
							};

							return $scope.input.appModel.createDimension(dimJSON).then((data) => {
								var obj = {templateId:aeTemplateId,qixId:data.id};
								$scope.input.idList.push(obj);
							});
						};

						/* Create Measure */
						$scope.createMeasure = function(aeExpression, aeTitle, aeDescription, aeTags, aeTemplateId){
							var mesJSON =
							{
								qInfo: {
									qType: "measure"
								},
								qMeasure: {
									qLabel:aeTitle,
									qGrouping: "N",
									qDef: aeExpression,
									qExpressions:[],
									qActiveExpression: 0
								},
								qMetaDef: {
									title:aeTitle,
									description:aeDescription,
									tags:aeTags
								}
							};

							return $scope.input.appModel.createMeasure(mesJSON).then((data) => {
								var obj = {templateId:aeTemplateId,qixId:data.id};
								$scope.input.idList.push(obj);
							});
						};

						/* Create Master Visualization */
						$scope.createMasterViz = function(aeVizTemplate){
							console.log('Create Viz');
							if(aeVizTemplate.type){
								$.getJSON('../extensions/AAIExpressionBuilder/templates/' + aeVizTemplate.type + '.json', function(response){
									var vizJSON = response;

									vizJSON.qMetaDef.title = aeVizTemplate.title;
									vizJSON.qMetaDef.description = aeVizTemplate.description;

									aeVizTemplate.replacements.forEach(function(r){
										$scope.input.idList.forEach(function(vid){
											if(vid.templateId == r.template){
												var obj = $scope.objectByString(vizJSON, r.path);
												obj[r.key] = vid.qixId;
											}
										});
									});
									$scope.input.appModel.createObject(vizJSON).then((data) => {console.log('Create Viz'); console.log(data);});
								});
							}
						};
					}]
				});
			}
		}]
	};
});
