define( [ "qlik",
'text!./template.ng.html',
'./definition',
'text!./dialog-template.ng.html',
'css!./AAIExpressionBuilderStyle.css',
'./wizardList',
'util',
'enigma',
'autogenerated/qix/engine-api'
],
function ( qlik, template, definition, dialogTemplate, cssStyle, wizardList, Util, enigma, schema) {
	'use strict';
	return {
		support : {
			snapshot: false,
			export: false,
			exportData : false
		},
		template: template,
		definition: definition,
		controller: ['$scope','luiDialog', function ( $scope, luiDialog) {
			$scope.wizardList = wizardList;
			$scope.layout = $scope.$parent.layout;
			console.log($scope);


			/* This function opens the dialog window when the openWizard() function
			is called */
			$scope.openWizard = function(){
				luiDialog.show({
					template: dialogTemplate,
					input: {
						selectedKey: '',
						wizardName: '',
						wizardList: $scope.wizardList,
						appModel: $scope.component.model.app,
						layout: $scope.layout,
						isLoading: false,
						enableVizBuild: true
					},
					controller: ['$scope', function( $scope ) {
						console.log($scope);

						/* Get current Qlik App and field list */
						var app = qlik.currApp(this);
						app.getList("FieldList", function(reply){
							$scope.input.fieldList = reply;
							console.log(reply);
						});

						/* This utility function is called when conversion a written JSON
						path from a config template and returnin the required object
						in the template */
						$scope.objectByString = function(o, s) {
							s = s.replace(/\[(\w+)\]/g, '.$1');
							s = s.replace(/^\./, '');
							var a = s.split('.');
							for (var i = 0, n = a.length; i < n; ++i) {
								var k = a[i];
								if (k in o) {
									o = o[k];
								} else {
									return;
								}
							}
							return o;
						};

						/* Set the default tab and create the function which will allow for
						the tab to be changed in code */
						$scope.tabs = 'tab1';
						$scope.make_tab_active = function(tabid) {
							$scope.tabs = 'tab'+tabid;
							console.log($scope.tabs);
						}

						$scope.make_tab_active(1);


						/* Prep the input list boxes that are used for parameter capture
						on the input form */
						$scope.input.idList = [];
						$scope.input.aggList = ['Count','Sum','Min','Max','Avg'];
						$scope.input.dateAggList = [
							{level:'Week', frequency:52},
							{level:'Month', frequency:12}
						];

						/* Function called when the selected wizard is changed using the
						onscreen drop down */
						$scope.changeWizard = function(wizKey){
							$scope.input.selectedKey = wizKey;
							$scope.input.wizardName = $scope.input.wizardList[wizKey].name;
							$scope.loadUI(wizKey);
						};

						//When any of the measures and dimensions are de-selected we must not produce visualizations as these will be incomplete
						$scope.$watch("input.codeTemplates", function(newValue, oldValue) {
							if(newValue){
								$scope.input.vizDisabled = false;
								newValue.forEach(function(entry){
									if(entry.enabled == false){
										$scope.input.vizDisabled = true;
									}
								});
							}
  					}, true);

						/* Loads the UI when a change to the wizard is made */
						$scope.loadUI = function(wizKey){
							$scope.input.uiarray = null;
							$scope.input.codeTemplates = null;
							$scope.input.isLoading = true;
							if($scope.input.wizardList[wizKey].config){
								require(['text!../extensions/AAIExpressionBuilder/wizards/'+ $scope.input.wizardList[wizKey].config + '.json'], function(wizardConfig) {
									var response = JSON.parse(wizardConfig);
									/* Parameters List */
									$scope.input.uiarray = response.parameters;
									$scope.input.uiarray.forEach(function(entry){
										entry.inputvalue = '';
									});

									/* Master Items to be created list */
									$scope.input.codeTemplates = response.templates;
									$scope.input.codeTemplates.forEach(function(entry){
										entry.enabled = true;
									});

									/* Visualizations to be created list */
									$scope.input.vizTemplates = response.viz;
									if($scope.input.vizTemplates){
										$scope.input.vizTemplates.forEach(function(entry){
											entry.enabled = true;
										});
									}
									$scope.input.vizDisabled = false;
									$scope.input.isLoading = false;
									$scope.$apply();
								});
							}
						};

						/* Called when the template parameters need to be turned into the
						Qlik expression that is required for the master item */
						$scope.completeTemplates = function(){
							$scope.input.codeTemplates.forEach(function(t){

								/* Process R scripts */
								if(t.scriptType.toUpperCase() == 'R'){
									if(!$scope.rScriptTemplate(t)) return false;
								}

								/* Process fields generated from Qlik native date fields */
								if(t.scriptType == 'nativedate'){
									if(!$scope.nativeDateTemplate(t)) return false;
								}

								/* Process a native Qlik field */
								if(t.scriptType == 'nativefield'){
									if(!$scope.nativeFieldTemplate(t)) return false;
								}

								/* Process a native Qlik aggregation field */
								if(t.scriptType == 'nativeagg'){
									if(!$scope.nativeFieldAggTemplate(t) return false;
								}

							});
							return true;
						};

						/* R script template processing */
						$scope.rScriptTemplate = function(t){
							t.outCode = null;

							if(t.enabled){
								//Process Template
								var rScript = t.rscript;
								var qParams = '';
								$scope.input.uiarray.forEach(function(p){
									//Replace Field with a dataframe column parameter
									var regExp = new RegExp('##<'+p.scriptid+'>##','g');
									rScript = rScript.replace(regExp,p.scriptid);

									//Replace With fieldname as is a Qlik native script function
									var regExp2 = new RegExp('#!<'+p.scriptid+'>!#','g');
									rScript = rScript.replace(regExp2,'['+p.inputvalue+']');

									//Date Parameter fields replaced with a parameter ralated to the field selection
									var regExpString = '!!<'+p.scriptid+'>!';
									var regExpParam = new RegExp(regExpString,'g');
									var match;
									while ((match = regExpParam.exec(rScript)) != null) {
    								console.log("match found at " + match.index);
										console.log(p);
										if(p.includedateagg){
											//We can expect the parameter after the scriptid match to be a parameter from the dateAggList

											var indexEndOfParameter = rScript.indexOf('!',match.index+regExpString.length);
											console.log(indexEndOfParameter);
											var parameterName = rScript.substring(match.index+regExpString.length,indexEndOfParameter);
											console.log(parameterName);

											//Get Date Agg Items
											$scope.input.dateAggList.forEach(function(entry){
												console.log(entry);
												if(p.dateaggvalue == entry.level){
													//Then check the
													console.log('Match with: ' + entry.level)
													console.log(entry[parameterName]);
													var replaceString = regExpString + parameterName + '!';
													console.log(replaceString);
													rScript = rScript.replace(replaceString,entry[parameterName]);
												}
											});
										}
									}

									if(p.includeinfunction){
										if(qParams != ''){
											qParams = qParams + ', ';
										}
										var expressionvalue = '';
										if(p.includeagg){
											expressionvalue = p.aggvalue + '([' + p.inputvalue + '])';
										}else{
											expressionvalue = '[' + p.inputvalue + ']';
										}
										qParams = qParams + expressionvalue + ' as ' + p.scriptid;
									}

								});

								var output = t.qlikfunction + '(\'' + rScript + '\',' + qParams + ')';

								t.outCode = output;
								return true;
							}else{
								return true; //Not Enabled is no reason to fail
							}
						};

						/* Native date functions */
						$scope.nativeDateTemplate = function(t){
							t.outCode = null;

							if(t.enabled){
								var output = '';
								//Would be better with a match, but looping for the moment!
								$scope.input.uiarray.forEach(function(p){
									if(p.scriptid == t.idForDate){
										//output = p.dateaggvalue + '([' + p.inputvalue + '])';
										output = '[' + p.inputvalue + ']';
									}
								});
								t.outCode = output;
								return true;
							}else{
								return true; //Not Enabled is no reason to fail
							}

						};

						/* Native field functions */
						$scope.nativeFieldTemplate = function(t){
							t.outCode = null;

							if(t.enabled){
								var output = '';
								//Would be better with a match, but looping for the moment!
								$scope.input.uiarray.forEach(function(p){
									if(p.scriptid == t.idForField){
										output = '[' + p.inputvalue + ']';
									}
								});
								t.outCode = output;
								return true;
							}else{
								return true; //Not Enabled is no reason to fail
							}
						};

						/* Native Aggregation functions */
						$scope.nativeFieldAggTemplate = function(t){
							t.outCode = null;

							if(t.enabled){
								if(!p.aggvalue) return false;
								if(!p.inputvalue) return false;
								var output = '';
								//Would be better with a match, but looping for the moment!
								$scope.input.uiarray.forEach(function(p){
									if(p.scriptid == t.idForField){
										output = p.aggvalue + '([' + p.inputvalue + '])';
									}
								});
								t.outCode = output;
								return true;
							}else{
								return true; //Not Enabled is no reason to fail
							}
						};

						/* Preview Master Items function, will complete each template so has to
						be called even if preview on screen is not required */
						$scope.previewMasterItems = function(){
							if($scope.completeTemplates()){
								$scope.make_tab_active(2);
								return true;
							}else{
								//Need to do something here to notify of the failure
								return false;
							}
						};

						/* Create Master Items */
						$scope.createMasterItems = function(){
							if($scope.previewMasterItems()){

								var p = [];
								$scope.input.codeTemplates.forEach(function(t){
									console.log(t.outCode);
									if(t.enabled){
										if(t.type.toUpperCase() == 'DIMENSION'){
											var a = $scope.createDimension(t.outCode, t.name, t.description, [], t.id);
											p.push(a);
										}
										if(t.type.toUpperCase() == 'MEASURE'){
											var a = $scope.createMeasure(t.outCode, t.name, t.description, [], t.id);
											p.push(a);
										}
									}
								});

								/* Only process after all promises have competed */
								Promise.all(p).then(values => {
									console.log($scope.input.dimList);
									console.log($scope.input.measureList);
									if($scope.input.vizTemplates){
										if(!$scope.input.vizDisabled){
											$scope.input.vizTemplates.forEach(function(v){
												$scope.createMasterViz(v);
											});
										}
									}
								});
							}else{
								//do something to say there was an error
							}
						};

						/* Create Dimension */
						$scope.createDimension = function(aeExpression, aeTitle, aeDescription, aeTags, aeTemplateId){
							var dimJSON =
							{
								qInfo: {
									qType: "dimension"
								},
								qDim: {
									qGrouping: "N",
									qFieldDefs: [
										aeExpression
									],
									qFieldLabels: [
										aeTitle
									],
									title:aeTitle
								},
								qMetaDef: {
									title:aeTitle,
									description:aeDescription,
									tags:aeTags
								}
							};

							return $scope.input.appModel.createDimension(dimJSON).then((data) => {
								var obj = {templateId:aeTemplateId,qixId:data.id};
								$scope.input.idList.push(obj);
							});
						};

						/* Create Measure */
						$scope.createMeasure = function(aeExpression, aeTitle, aeDescription, aeTags, aeTemplateId){
							var mesJSON =
							{
								qInfo: {
									qType: "measure"
								},
								qMeasure: {
									qLabel:aeTitle,
									qGrouping: "N",
									qDef: aeExpression,
									qExpressions:[],
									qActiveExpression: 0
								},
								qMetaDef: {
									title:aeTitle,
									description:aeDescription,
									tags:aeTags
								}
							};

							return $scope.input.appModel.createMeasure(mesJSON).then((data) => {
								var obj = {templateId:aeTemplateId,qixId:data.id};
								$scope.input.idList.push(obj);
							});
						};

						/* Create Master Visualization */
						$scope.createMasterViz = function(aeVizTemplate){
							console.log('Create Viz');
							if(aeVizTemplate.type){
								$.getJSON('../extensions/AAIExpressionBuilder/templates/' + aeVizTemplate.type + '.json', function(response){
									var vizJSON = response;

									vizJSON.qMetaDef.title = aeVizTemplate.title;
									vizJSON.qMetaDef.description = aeVizTemplate.description;

									aeVizTemplate.replacements.forEach(function(r){
										$scope.input.idList.forEach(function(vid){
											if(vid.templateId == r.template){
												var obj = $scope.objectByString(vizJSON, r.path);
												obj[r.key] = vid.qixId;
											}
										});
									});
									$scope.input.appModel.createObject(vizJSON).then((data) => {console.log('Create Viz'); console.log(data);});
								});
							}
						};
					}]
				});
			}
		}]
	};
});
